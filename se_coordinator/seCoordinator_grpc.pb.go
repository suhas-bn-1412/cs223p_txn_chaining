// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v3.20.3
// source: proto/seCoordinator.proto

package se_coordinator

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
	SeCoordinator_CreateUser_FullMethodName        = "/se_coordinator.SeCoordinator/CreateUser"
	SeCoordinator_AddSymbol_FullMethodName         = "/se_coordinator.SeCoordinator/AddSymbol"
	SeCoordinator_UpdatePrice_FullMethodName       = "/se_coordinator.SeCoordinator/UpdatePrice"
	SeCoordinator_BuyLocal_FullMethodName          = "/se_coordinator.SeCoordinator/BuyLocal"
	SeCoordinator_BuyInternational_FullMethodName  = "/se_coordinator.SeCoordinator/BuyInternational"
	SeCoordinator_SellLocal_FullMethodName         = "/se_coordinator.SeCoordinator/SellLocal"
	SeCoordinator_SellInternational_FullMethodName = "/se_coordinator.SeCoordinator/SellInternational"
	SeCoordinator_CheckBalance_FullMethodName      = "/se_coordinator.SeCoordinator/CheckBalance"
)

// SeCoordinatorClient is the client API for SeCoordinator service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SeCoordinatorClient interface {
	CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error)
	AddSymbol(ctx context.Context, in *AddSymbolRequest, opts ...grpc.CallOption) (*AddSymbolResponse, error)
	UpdatePrice(ctx context.Context, in *UpdatePriceRequest, opts ...grpc.CallOption) (*UpdatePriceResponse, error)
	BuyLocal(ctx context.Context, in *BuyLocalRequest, opts ...grpc.CallOption) (*BuyLocalResponse, error)
	BuyInternational(ctx context.Context, in *BuyInternationalRequest, opts ...grpc.CallOption) (*BuyInternationalResponse, error)
	SellLocal(ctx context.Context, in *SellLocalRequest, opts ...grpc.CallOption) (*SellLocalResponse, error)
	SellInternational(ctx context.Context, in *SellInternationalRequest, opts ...grpc.CallOption) (*SellInternationalResponse, error)
	CheckBalance(ctx context.Context, in *CheckBalanceRequest, opts ...grpc.CallOption) (*CheckBalanceResponse, error)
}

type seCoordinatorClient struct {
	cc grpc.ClientConnInterface
}

func NewSeCoordinatorClient(cc grpc.ClientConnInterface) SeCoordinatorClient {
	return &seCoordinatorClient{cc}
}

func (c *seCoordinatorClient) CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateUserResponse)
	err := c.cc.Invoke(ctx, SeCoordinator_CreateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seCoordinatorClient) AddSymbol(ctx context.Context, in *AddSymbolRequest, opts ...grpc.CallOption) (*AddSymbolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddSymbolResponse)
	err := c.cc.Invoke(ctx, SeCoordinator_AddSymbol_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seCoordinatorClient) UpdatePrice(ctx context.Context, in *UpdatePriceRequest, opts ...grpc.CallOption) (*UpdatePriceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdatePriceResponse)
	err := c.cc.Invoke(ctx, SeCoordinator_UpdatePrice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seCoordinatorClient) BuyLocal(ctx context.Context, in *BuyLocalRequest, opts ...grpc.CallOption) (*BuyLocalResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BuyLocalResponse)
	err := c.cc.Invoke(ctx, SeCoordinator_BuyLocal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seCoordinatorClient) BuyInternational(ctx context.Context, in *BuyInternationalRequest, opts ...grpc.CallOption) (*BuyInternationalResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BuyInternationalResponse)
	err := c.cc.Invoke(ctx, SeCoordinator_BuyInternational_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seCoordinatorClient) SellLocal(ctx context.Context, in *SellLocalRequest, opts ...grpc.CallOption) (*SellLocalResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SellLocalResponse)
	err := c.cc.Invoke(ctx, SeCoordinator_SellLocal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seCoordinatorClient) SellInternational(ctx context.Context, in *SellInternationalRequest, opts ...grpc.CallOption) (*SellInternationalResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SellInternationalResponse)
	err := c.cc.Invoke(ctx, SeCoordinator_SellInternational_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seCoordinatorClient) CheckBalance(ctx context.Context, in *CheckBalanceRequest, opts ...grpc.CallOption) (*CheckBalanceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckBalanceResponse)
	err := c.cc.Invoke(ctx, SeCoordinator_CheckBalance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SeCoordinatorServer is the server API for SeCoordinator service.
// All implementations must embed UnimplementedSeCoordinatorServer
// for forward compatibility
type SeCoordinatorServer interface {
	CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error)
	AddSymbol(context.Context, *AddSymbolRequest) (*AddSymbolResponse, error)
	UpdatePrice(context.Context, *UpdatePriceRequest) (*UpdatePriceResponse, error)
	BuyLocal(context.Context, *BuyLocalRequest) (*BuyLocalResponse, error)
	BuyInternational(context.Context, *BuyInternationalRequest) (*BuyInternationalResponse, error)
	SellLocal(context.Context, *SellLocalRequest) (*SellLocalResponse, error)
	SellInternational(context.Context, *SellInternationalRequest) (*SellInternationalResponse, error)
	CheckBalance(context.Context, *CheckBalanceRequest) (*CheckBalanceResponse, error)
	mustEmbedUnimplementedSeCoordinatorServer()
}

// UnimplementedSeCoordinatorServer must be embedded to have forward compatible implementations.
type UnimplementedSeCoordinatorServer struct {
}

func (UnimplementedSeCoordinatorServer) CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedSeCoordinatorServer) AddSymbol(context.Context, *AddSymbolRequest) (*AddSymbolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddSymbol not implemented")
}
func (UnimplementedSeCoordinatorServer) UpdatePrice(context.Context, *UpdatePriceRequest) (*UpdatePriceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePrice not implemented")
}
func (UnimplementedSeCoordinatorServer) BuyLocal(context.Context, *BuyLocalRequest) (*BuyLocalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BuyLocal not implemented")
}
func (UnimplementedSeCoordinatorServer) BuyInternational(context.Context, *BuyInternationalRequest) (*BuyInternationalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BuyInternational not implemented")
}
func (UnimplementedSeCoordinatorServer) SellLocal(context.Context, *SellLocalRequest) (*SellLocalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SellLocal not implemented")
}
func (UnimplementedSeCoordinatorServer) SellInternational(context.Context, *SellInternationalRequest) (*SellInternationalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SellInternational not implemented")
}
func (UnimplementedSeCoordinatorServer) CheckBalance(context.Context, *CheckBalanceRequest) (*CheckBalanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckBalance not implemented")
}
func (UnimplementedSeCoordinatorServer) mustEmbedUnimplementedSeCoordinatorServer() {}

// UnsafeSeCoordinatorServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SeCoordinatorServer will
// result in compilation errors.
type UnsafeSeCoordinatorServer interface {
	mustEmbedUnimplementedSeCoordinatorServer()
}

func RegisterSeCoordinatorServer(s grpc.ServiceRegistrar, srv SeCoordinatorServer) {
	s.RegisterService(&SeCoordinator_ServiceDesc, srv)
}

func _SeCoordinator_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeCoordinatorServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SeCoordinator_CreateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeCoordinatorServer).CreateUser(ctx, req.(*CreateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SeCoordinator_AddSymbol_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddSymbolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeCoordinatorServer).AddSymbol(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SeCoordinator_AddSymbol_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeCoordinatorServer).AddSymbol(ctx, req.(*AddSymbolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SeCoordinator_UpdatePrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeCoordinatorServer).UpdatePrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SeCoordinator_UpdatePrice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeCoordinatorServer).UpdatePrice(ctx, req.(*UpdatePriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SeCoordinator_BuyLocal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuyLocalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeCoordinatorServer).BuyLocal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SeCoordinator_BuyLocal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeCoordinatorServer).BuyLocal(ctx, req.(*BuyLocalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SeCoordinator_BuyInternational_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuyInternationalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeCoordinatorServer).BuyInternational(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SeCoordinator_BuyInternational_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeCoordinatorServer).BuyInternational(ctx, req.(*BuyInternationalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SeCoordinator_SellLocal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SellLocalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeCoordinatorServer).SellLocal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SeCoordinator_SellLocal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeCoordinatorServer).SellLocal(ctx, req.(*SellLocalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SeCoordinator_SellInternational_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SellInternationalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeCoordinatorServer).SellInternational(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SeCoordinator_SellInternational_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeCoordinatorServer).SellInternational(ctx, req.(*SellInternationalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SeCoordinator_CheckBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeCoordinatorServer).CheckBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SeCoordinator_CheckBalance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeCoordinatorServer).CheckBalance(ctx, req.(*CheckBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SeCoordinator_ServiceDesc is the grpc.ServiceDesc for SeCoordinator service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SeCoordinator_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "se_coordinator.SeCoordinator",
	HandlerType: (*SeCoordinatorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateUser",
			Handler:    _SeCoordinator_CreateUser_Handler,
		},
		{
			MethodName: "AddSymbol",
			Handler:    _SeCoordinator_AddSymbol_Handler,
		},
		{
			MethodName: "UpdatePrice",
			Handler:    _SeCoordinator_UpdatePrice_Handler,
		},
		{
			MethodName: "BuyLocal",
			Handler:    _SeCoordinator_BuyLocal_Handler,
		},
		{
			MethodName: "BuyInternational",
			Handler:    _SeCoordinator_BuyInternational_Handler,
		},
		{
			MethodName: "SellLocal",
			Handler:    _SeCoordinator_SellLocal_Handler,
		},
		{
			MethodName: "SellInternational",
			Handler:    _SeCoordinator_SellInternational_Handler,
		},
		{
			MethodName: "CheckBalance",
			Handler:    _SeCoordinator_CheckBalance_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/seCoordinator.proto",
}
